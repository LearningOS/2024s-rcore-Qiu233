# 实现功能

* 重写`sys_get_time`和`sys_task_info`，利用一个仓库原有的`translated_byte_buffer`函数和自己实现的`copy_to_segs`函数在用户空间和内核空间之间复制数据。
* 修改原有code base，利用`Result`引入错误码，消除几乎全部`unwrap`，某些不该出错的除外。后续章节这部分没有沿用，因为修改过多，git merge过于困难。
* 实现`sys_mmap`，惰性分配，参数范围不得与已有的area重叠，不得含有`TRAMPOLINE`或`TRAP_CONTEXT_BASE`。实际分配代码(见`MemoryArea::ensure_page_raw`)会在映射失败时回收`FrameTracker`。
* 实现`sys_munmap`，参数必须全部都是已有area的部分，不得含有`TRAMPOLINE`或`TRAP_CONTEXT_BASE`。**只有刚刚好在指定范围中的虚拟页会被unmap，否则原area会被拆分，不在范围内的部分会被保留。**
* 将原有`MemorySet::push`分成不同的`push_strict`和`push_lazy`，只有`TRAP_CONTEXT_BASE`和从ELF加载的LOAD段用`push_strict`。
* `push_lazy`在数据参数不为`None`时会立刻分配足够物理内存。


# 问答题

## Sv39页表项
据[文档](https://five-embeddev.com/riscv-priv-isa-manual/Priv-v1.12/supervisor.html#sec:sv39)，从低到高前十位分别是：

0. V：表示entry是否有效，无效的entry会被MMU忽略
1. R：表示是否可读
2. W：表示是否可写
3. X：表示是否可执行
4. U：用户态(U模式)是否可访问
5. G：全局页表，TLB刷新时会被保留
6. A：自上次被置0后是否发生了访问
7. D：自上次被置0后是否发生了写入
8. RSW：占两位，文档未规定用途，可由操作系统利用

[10:53]位是PPN，分成三段：
* [10:18]是PPN[0]，长度9位
* [19:27]是PPN[1]，长度9位
* [28:53]是PPN[2]，长度26位

如果entry是叶子节点，那么PPN的部分位或全部位，在MMU转换地址时，将被复制到转换产生的物理页号中，取决于叶子节点处于哪一层：
* 第3层的叶子节点会把整个PPN复制，本章只有这种情况
* 第`i`层的叶子节点只会复制`PPN[(3-i):2]`，这种叫做superpage

[54:60]位保留至将来的标准使用，软件应当置0保证兼容性。

63位和[61:62]位由Svnapot和Svpbmt扩展定义，不过似乎课程并未提及这两个字段的意义，文档有关部分我暂时没有深入阅读。

## 缺页
据文档[riscv-privileged-20190608-1](https://riscv.org/wp-content/uploads/2019/08/riscv-privileged-20190608-1.pdf)的3.1.16节，共有三种与缺页有关的异常：

* 12-Instruction page fault：指令执行错误
* 13-Load page fault：读取错误
* 15-Store/AMO page fault：写入或原子内存指令错误

发生缺页时：
* `scause`寄存器会被设置为以上三者之一，表示缺页的原因。
* `stval`寄存器保存被访问的目标**地址**。
* `sepc`寄存器保存发生异常的位置。


### Lazy的好处
* 减少程序初始化的耗时。
* 减少同一时刻被使用的内存总量。
* 分配的物理内存不会超过软件所实际需要的总量，即便软件名义上申请的超出了这部分。

### 10G内存的页表大小

首先计算页数：

> (10 * 0x4000_0000) / 4096 = 2621440 (页)

因为一页可以存`2^9 = 512`个项，所以**仅第三层的叶子节点**需要：

> 2621440 / 512 = 5120 (页)

由于题目问的是**连续的内存页面**，那么可以假设每一层的节点都非常紧凑，所以第二层的节点大致需要：

> 5120 / 512 = 10 (页)

第一层需要：

> ceil(10 / 512) = 1 (页)

可见第一层和第二层对数量级的影响很小，用第三层的数据估算即可：

> 5120 * 4096 = 20971520 (Bytes) = 20 (MiB)

综上，大致需要20MiB内存。

### Lazy实现的策略
我已在实验代码中实现Lazy分配策略，关键在于：

* 当缺页异常发生时，trap handler应当根据缺页的位置(`stval`寄存器中)判断该虚拟页是否在某个area中，若不在则程序出错结束，若在则进行访问的合法判断：
* 合法判断：用`MemorySet::translate`得到PTE判断是否具有需要的权限(X、W、R位)，本次实验无需检查U位，因为进程的地址空间只有U位为1的映射。
* 如果原有地址已在某个area中但是未分配对应的Frame，上一条的`MemorySet::translate`函数就会立刻分配一个Frame并在映射后返回PTE。

如果是Lazy加载，例如从只读内存区域或者外部设备(如硬盘)读取数据，应当保证：
* 数据源在加载命令后、实际加载前不会被更改，否则应该像linux一样报错"Test file busy"。

更有趣的情况是COW(Copy On Write)，例如Windows的模块的数据段(假设无重定位)：
* 多个进程加载同一个模块，初始时数据段共享同一块物理内存区域。
* 如果某个进程尝试修改，那么Windows会为它分配数据段内存并复制数据。

Swap策略中，要使页面失效只需要将PTE的0号位(字段`V`)清除即可，MMU转换对应虚拟页时会触发page fault。

## 双页表与单页表

单页表的情况下，在`__switch`中保存当前页表token，并将下一个任务的页表设置到`satp`中，如此更换页表。

要控制用户态无法访问内核页面，只需要将PTE的4号位(字段`U`)清除即可。

单页表的优势在于：
* 内核态与用户态地址空间相同，trap发生时不必切换，因此TLB仍然有效。
* 内核态可以直接使用来自用户态的指针(`sstatus.SUM=1`时)，传递数据更加简单且迅速。


双页表实现下：
* 发生trap时，保存状态后，但在进入trap handler执行内核代码之前，即`__alltraps`的尾部，更换页表为内核空间。
* 在`__restore`的头部，即恢复状态之前更换页表为任务的地址空间。

如果我写一个单页表操作系统，会选择在进程切换时更换页表，一般的trap不发生更换。更换方式已在本节开头说过。

# 荣誉准则

1. 在完成本次实验的过程（含此前学习的过程）中，我曾分别与以下各位就（与本次实验相关的）以下方面做过交流，还在代码中对应的位置以注释形式记录了具体的交流对象及内容：

* 无。直到完成为止，我未与任何人交流本章内容。

2. 此外，我也参考了 以下资料 ，还在代码中对应的位置以注释形式记录了具体的参考来源及内容：

* 非代码资料是手册[riscv-privileged-20190608-1](https://riscv.org/wp-content/uploads/2019/08/riscv-privileged-20190608-1.pdf)。
* 代码实现并未参考任何已有资料，未使用任何AI生成的代码，代码实现全部由我个人完成。

3. 我独立完成了本次实验除以上方面之外的所有工作，包括代码与文档。 我清楚地知道，从以上方面获得的信息在一定程度上降低了实验难度，可能会影响起评分。

4. 我从未使用过他人的代码，不管是原封不动地复制，还是经过了某些等价转换。 我未曾也不会向他人（含此后各届同学）复制或公开我的实验代码，我有义务妥善保管好它们。 我提交至本实验的评测系统的代码，均无意于破坏或妨碍任何计算机系统的正常运转。 我清楚地知道，以上情况均为本课程纪律所禁止，若违反，对应的实验成绩将按“-100”分计。