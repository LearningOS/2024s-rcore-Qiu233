# 实现功能
死锁检测，十分简单的算法，同时对Mutex和Semaphore生效，需要动态追踪资源的可用数量和分配数量来判断死锁，判断时暂时将矩阵项`Q[tid][sid]`加一，然后执行算法检查当前是否安全，如果安全才让过，否则直接返回-0xDEAD。

另外按照这个算法，测例里的MPSC如果开了死锁检测就过不了，原因是释放semaphore的线程和创建的不是同一个，此时对线程分配数量的追踪就失去意义了，不过好在测例的MPSC没开死锁检测，所以险过。

# 问答作业
1. TCB可能被如下位置引用：

* `TimerCondVar`：由`remove_inactive_task`回收，被`exit_current_and_run_next`调用。
* `TaskManager.ready_queue`：同上`remove_inactive_task`回收。
* `CondVarInner.wait_queue`：进程结束时保存CondVar的Vec会被回收，因此自动被回收。
* `SemaphoreInner`：同理，自动被回收。
* `MutexBlockingInner`：同理，自动被回收。
* `ProcessControlBlockInner.tasks`：PCB被销毁时自动被回收。
* `Processor.current`：该任务调用`exit_current_and_run_next`被回收。


2. 这两种实现都有逻辑问题：

* 第一种实现将locked设为false，但`wait_queue`不一定为空，如果不为空，那么逻辑上此时locked应当保持true，表示弹出的任务获得了锁。另一个问题是`add_task`，和第二种实现一样，下面一起说：
* 第一、二种实现都用`add_task`直接将任务加入调度，但此时任务的状态还是`Blocked`。虽然本章代码没有检查任务状态，应该不会有问题，但良好的任务状态对系统的可维护性很重要。

# 荣誉准则

1. 在完成本次实验的过程（含此前学习的过程）中，我曾分别与以下各位就（与本次实验相关的）以下方面做过交流，还在代码中对应的位置以注释形式记录了具体的交流对象及内容：

* 无。直到完成为止，我未与任何人交流本章内容。

2. 此外，我也参考了以下资料 ，还在代码中对应的位置以注释形式记录了具体的参考来源及内容：

* 死锁检测算法原理参考书籍《操作系统——精髓与设计原理（第八版）》第6.4节。
* 代码实现并未参考任何已有资料，未使用任何AI生成的代码，代码实现全部由我个人完成。

3. 我独立完成了本次实验除以上方面之外的所有工作，包括代码与文档。 我清楚地知道，从以上方面获得的信息在一定程度上降低了实验难度，可能会影响起评分。

4. 我从未使用过他人的代码，不管是原封不动地复制，还是经过了某些等价转换。 我未曾也不会向他人（含此后各届同学）复制或公开我的实验代码，我有义务妥善保管好它们。 我提交至本实验的评测系统的代码，均无意于破坏或妨碍任何计算机系统的正常运转。 我清楚地知道，以上情况均为本课程纪律所禁止，若违反，对应的实验成绩将按“-100”分计。
